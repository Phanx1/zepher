
PASSING DATA
Fifo, lifo, stack, message queue, mailbox, pipes for passing data between threads or between an ISR and a thread
For more in-depth and examples https://docs.zephyrproject.org/1.9.0/kernel/data_passing/data_passing.html

FIFO
Any number of fifos can be defined. They are referenced by their memory address. 
Implemented as a simple linked list queue of items that have been added but not yet removed.
Size wise if the data is N bytes, the pointer too next piece of data is 4 bytes. So N+4 for the total data.
Data can be added by a thread or an ISR, only can be removed by a thread (the kernel allows an ISR to remove and item from a fifo, however the ISR must not wait for fifo empty)
	A thread can wait for a fifo to have something added in which case it is given to the highest priority thread that has waited longest
Multiple items can be added at once if they are in a linked list

LIFO
Any number of lifo can be defined. Each lifo is referenced by its memory address
Implemented as a simple linked list.
Same restrictions for adding and removing as a fifo

STACK
Any number of stacks can be defined. Referenced by its memory address.
A queue of 32-bit values, implemented with an array of 32-bit integers and must be aligned on a 4-byte boundary
Stack must have maximum quantity of values that can be queued in the array
Data can be added to a stack by a thread or an ISR the value is given to a waiting thread if there is one, or added tot the lifo queue. The kernel does not detect attempts to add a data value to a stack at the maximum quantity
Same restrictions for ISR removing. It can, but it must not wait if the stack is empty

MESSAGE QUEUE
Any number of message queues can be defined. Each message queue is referenced by its memory address
A message queue has: a ring buffer of data items sent but not yet received, a data item size in bytes, and a maximum quantity of data items that can be queued in the ring buffer
A message queues ring buffer must be aligned to an N-byte boundary, where N is a power of 2
A data item can be sent by a thread or ISR, the data item pointed at by sending thread is copied to a waiting thread. If no waiting thread exists, the item is copied to the message queue's ring buffer. The size of the data area being sent must equal the message queues data item size. (Since this copies should be passing pointers)
If a thread attempt to receive a data time when the ring buffer is empty the receiving thread can wait for a data item to be sent. Multiple cane wait of the same message queue


MAILBOX
Is an improved message queue. Allows threads to send and receive messages of any size synchronously or async 
Has a send queue and a receive queue
Allows threads to exchange messages
Each message may be received by only one thread. 


PIPES
Allows a thread to send a byte stream to another thread
Has a property for size. If size is 0 a pipe with no ring buffer is defined. 
Data can be synchronously or async.
Sync sent either in whole or part. Accepted data is copied tot he pipe's ring buffer or directly to the waiting read thread
Async can be sent with a memory block. Once accepted the memory block is freed and a semaphore can be used to show completion

